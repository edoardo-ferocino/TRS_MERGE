<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>scTDC: scTDC library interface</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">scTDC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">scTDC library interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="version"><dt><b>Version:</b></dt><dd>1.1411</dd></dl>
<p>This is documentation for scTDC library API. scTDC library is used for access to Surface Concept GmbH Time to Digital Converter and Delay Line Detector devices.</p>
<h2><a class="anchor" id="intro"></a>
Intro</h2>
<p>Starting from the version 1.4.0 of scTDC library new abstraction was implemented to extract tdc and dld data from the device. The main mechanism for that is something which is called data pipe. Data pipes can be of different type and have different parameter. Every data pipe get pipe ident number when is opened with <a class="el" href="sc_t_d_c_8h.html#afbccffe9f8d461337272c77b1e8d99e9" title="Open data pipe.">sc_pipe_open2()</a> function. There could be as many pipes opened as application requires. After measure is started with sc_start_measure2() application should read the data from the data pipe with the <a class="el" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2()</a> function. When operation is finished data pipe should be closed with <a class="el" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2()</a>.</p>
<p>Here is minimal example how things should be done: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//c99 compiler must be used</span>
<span class="preprocessor">#include &lt;<a class="code" href="sc_t_d_c_8h.html">scTDC.h</a>&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keywordtype">int</span> main()
{
  <span class="keywordtype">int</span> dd = <a class="code" href="sc_t_d_c_8h.html#a11d123aaa034fedaaa321e90a9f28176" title="Initializes the hardware and loads the initial settings reading it from ini file.">sc_tdc_init_inifile</a>(<span class="stringliteral">&quot;tdc_gpx3.ini&quot;</span>);
  <span class="keywordflow">if</span> (dd &lt; 0) { <span class="comment">// could not initialise hardware. dd contains error code</span>
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(dd, error_description);
    puts(error_description);
    <span class="keywordflow">return</span> dd;
  } <span class="keywordflow">else</span> { <span class="comment">//dd is device descriptor which could be used for any other operation</span>
    <span class="keywordtype">double</span> tdc_binsize;
    <span class="keywordtype">int</span> ret = <a class="code" href="sc_t_d_c_8h.html#a6a3ce6445e74359463ada0639c304b7d" title="Get binning.">sc_tdc_get_binsize2</a>(dd, &amp;tdc_binsize);
    <span class="keywordflow">if</span> (ret &lt; 0) { <span class="comment">//if there is error happened.</span>
      puts(<span class="stringliteral">&quot;could not get binsize&quot;</span>);
      <span class="keywordflow">return</span> ret;
    }
    printf(<span class="stringliteral">&quot;tdc binsize is %lf\n&quot;</span>, tdc_binsize);

    <span class="comment">//now lets try to open tdc_histo pipe</span>

    <span class="keyword">struct </span><a class="code" href="structsc__pipe__tdc__histo__params__t.html" title="Parameters for TDC_HISTO pipe type.">sc_pipe_tdc_histo_params_t</a> params;
    params.<a class="code" href="structsc__pipe__tdc__histo__params__t.html#a8da63a6e408a5a42333b03c4328a9810">depth</a> = <a class="code" href="sc_t_d_c__types_8h.html#a0ae49d912d694db36d79ce9cc88d5e6eaaff04ad1d507e6ce650ed3fd28dcb721">BS32</a>; <span class="comment">// 32 bit per time channel (point) in the histogram</span>
    params.channel = 0; <span class="comment">// pipe for channel #0 is requested</span>
    params.modulo = 0; <span class="comment">// modulo is off</span>
    params.binning = 4; <span class="comment">// histogram binning is set to 4</span>
    params.offset = 1000; <span class="comment">// histogram starts from the 1000 time bins (see sc_tdc_get_binsize2()).</span>
    params.size = 2000; <span class="comment">// histogram size is 2000 time bins (but note binning)!</span>
    params.accumulation_ms = 0; <span class="comment">// accumulation is off</span>
    params.allocator_owner = NULL; <span class="comment">// parameter for allocator cbf</span>
    params.allocator_cb = NULL; <span class="comment">// internal allocator is used</span>

    <span class="keywordtype">int</span> pipe_id = <a class="code" href="sc_t_d_c_8h.html#afbccffe9f8d461337272c77b1e8d99e9" title="Open data pipe.">sc_pipe_open2</a>(dd, <a class="code" href="sc_t_d_c__types_8h.html#a207ff2479453c33d928ad188b7f43ad2a62a23cd0d43c32ca8763b706e8d278d7">TDC_HISTO</a>, (<span class="keywordtype">void</span> *)&amp;params);
    <span class="keywordflow">if</span> (pipe_id &lt; 0) { <span class="comment">//pipe_id contains error code</span>
      <span class="keywordtype">char</span> error_description[ERRSTRLEN];
      <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(pipe_id, error_description);
      puts(error_description);
      <span class="keywordflow">return</span> pipe_id;
    }

    <a class="code" href="sc_t_d_c_8h.html#a17cad5640ea7fda18cac602590b096ba" title="Start measure.">sc_tdc_start_measure2</a>(dd, 1000); <span class="comment">//start 1000 ms measure</span>

    <span class="keywordtype">unsigned</span> *tdc_histo;
    ret = <a class="code" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2</a>(dd, pipe_id, (<span class="keywordtype">void</span> *)&amp;tdc_histo, -1); <span class="comment">//after the call</span>
    <span class="comment">//tdc_histo pointer will point on the histogram data. The place for the</span>
    <span class="comment">//histogram will be allocated by internal allocator and will be destroyed</span>
    <span class="comment">//at next call. -1 means wait infinitely (2^32 milliseconds).</span>

    <span class="keywordflow">if</span> (ret &lt; 0) { <span class="comment">//note that this could be timeout as well</span>
      <span class="keywordtype">char</span> error_description[ERRSTRLEN];
      <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(pipe_id, error_description);
      puts(error_description);
      <span class="keywordflow">return</span> ret;
    }

    <span class="comment">//now we have data, may process it or show somewhere</span>

    <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pipe_id);

    <span class="comment">//here data pipe is closed. NOTE: tdc_histo now points to nowhere. If</span>
    <span class="comment">//application needs tdc_data at this point - copy it before calling</span>
    <span class="comment">//sc_pipe_close2().</span>

    <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd); <span class="comment">// release hardware and resources.</span>
    <span class="keywordflow">return</span> 0;
  }
}
</pre></div><h2><a class="anchor" id="configuration"></a>
Configuration</h2>
<p>To configure scTDC1 library application must supply inifile and firmware file (both supplied with the device). Inifile contains information about firmware file which will be used. That's why sc_tdc_init_inifile2() call takes only one parameter which is the name of the inifile. sc_tdc_init_inifile2() call returns positive integer number which serves as a device descriptor and must be user in all other calls related to the configured device. Negative returned value means error. There can be text description of the error obtained with the <a class="el" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg()</a> call.</p>
<h2><a class="anchor" id="start_measure"></a>
Start Measure</h2>
<p><a class="el" href="sc_t_d_c_8h.html#a17cad5640ea7fda18cac602590b096ba" title="Start measure.">sc_tdc_start_measure2()</a> is used to start measure procedure. After the call device goes to the measurement state, extracts data from the device analizes it and transfers to the application through data pipes which must be configured previously. See <a class="el" href="index.html#extracting_data">Extracting Data</a> section for more info how to operate with data pipes. In case of external start <a class="el" href="sc_t_d_c_8h.html#a17cad5640ea7fda18cac602590b096ba" title="Start measure.">sc_tdc_start_measure2()</a> call only transfer scTDC1 to the state of waiting for the start pulse on the device input. Currently external start feature must be switched in the inifile. Unfortunately there is no way to do that through scTDC API but this may be changed in future.</p>
<h2><a class="anchor" id="extracting_data"></a>
Extracting Data</h2>
<p>The main abstraction unit of the scTDC1 API which intend to be used for extracting processed (or raw) data from the library is a data pipe. Application can open as many data pipes as required for operation. All of them can have their own parameters, settings and types. The only limitation is the machine resources like memory and processor power. Due to of historical and optimisation reasons the processing happens in only one thread. This means that amount of time required to process one data unit (some number of tdc events) is linearly growing up with number of data pipes opened. The data processing mechanism may be changed in the future to be multithread.</p>
<p>Data pipe can be opened with <a class="el" href="sc_t_d_c_8h.html#afbccffe9f8d461337272c77b1e8d99e9" title="Open data pipe.">sc_pipe_open2()</a> call. Data can be extracted with <a class="el" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2()</a> call. <a class="el" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2()</a> call is used to close pipe and free resources used.</p>
<p>Here is a little example how data pipe for 2d images can be opened and operated (2d images available only when using dld device). </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> image2d_ex() <span class="comment">// 2d image example.</span>
{
  <span class="keyword">const</span> uint32_t size_x = 512;
  <span class="keyword">const</span> uint32_t size_y = 512;

  <span class="keywordtype">int</span> dd = <a class="code" href="sc_t_d_c_8h.html#a11d123aaa034fedaaa321e90a9f28176" title="Initializes the hardware and loads the initial settings reading it from ini file.">sc_tdc_init_inifile</a>(<span class="stringliteral">&quot;tdc_gpx3.ini&quot;</span>); <span class="comment">//init the hardware and get device descriptor</span>
  <span class="keywordflow">if</span> (dd &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(dd, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, dd, error_description);
    <span class="keywordflow">return</span> dd;
  }

  <span class="keyword">struct </span><a class="code" href="structsc__pipe__dld__image__xy__params__t.html" title="Parameters for DLD_IMAG_XY pipe type.">sc_pipe_dld_image_xy_params_t</a> prms;
  memset(&amp;prms, 0, <span class="keyword">sizeof</span>(prms));
  prms.depth = <a class="code" href="sc_t_d_c__types_8h.html#a0ae49d912d694db36d79ce9cc88d5e6eaaff04ad1d507e6ce650ed3fd28dcb721">BS32</a>; <span class="comment">//4 bytes per pixel in the image</span>
  prms.channel = -1; <span class="comment">//all channels together</span>
  prms.binning = {1, 1, 1};
  prms.roi = {{0,0,0}, {size_x, size_y, -1}};

  <span class="keywordtype">int</span> pd = <a class="code" href="sc_t_d_c_8h.html#afbccffe9f8d461337272c77b1e8d99e9" title="Open data pipe.">sc_pipe_open2</a>(dd, <a class="code" href="sc_t_d_c__types_8h.html#a207ff2479453c33d928ad188b7f43ad2acc30ac51fcc74e245ee50affc0ed8eb5">DLD_IMAGE_XY</a>, (<span class="keywordtype">void</span> *)&amp;prms); <span class="comment">//init image 2d pipe and get pipe descriptor</span>
  <span class="comment">//can be called several times with different parameters if necessary</span>
  <span class="keywordflow">if</span> (pd &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(pd, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, pd, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd);
    <span class="keywordflow">return</span> pd;
  }

  <span class="keywordtype">int</span> ret = <a class="code" href="sc_t_d_c_8h.html#a17cad5640ea7fda18cac602590b096ba" title="Start measure.">sc_tdc_start_measure2</a>(dd, 200); <span class="comment">//start 200 ms measure</span>
  <span class="keywordflow">if</span> (ret &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(ret, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, ret, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
    <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd);
    <span class="keywordflow">return</span> ret;
  }

  uint32_t *image;
  <span class="comment">//This will unblock when exposure finished. image will be set to internally</span>
  <span class="comment">// allocated image data. Size of the image is roi_x  * roi_y * 4</span>
  <span class="comment">// Here it will be 512 * 512 * 4 (see prms.roi and prms.depth settings).</span>
  <span class="comment">// Deallocation happens when next sc_pipe_read2(), sc_pipe_close2() or</span>
  <span class="comment">//sc_tdc_deinit2() call.</span>
  ret = <a class="code" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2</a>(dd, pd, (<span class="keywordtype">void</span> **) &amp;image, UINT32_MAX);
  <span class="keywordflow">if</span> (ret &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(ret, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, ret, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
    <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd);
    <span class="keywordflow">return</span> ret;
  }

  <span class="comment">// Here application should do necessary actions with the image.</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;size_x * size_y; ++i) {
    fprintf(stderr, <span class="stringliteral">&quot;%08x\n&quot;</span>, image[i]);
  }

  <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
  <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd);
  fprintf(stderr, <span class="stringliteral">&quot;\n&quot;</span>);
  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="memory_notes"></a>
Data Pipe Memory Usage Notes</h2>
<p>Due to of non-automatic memory handling in C programming language the question of allocation and deallocation memory is very important. Currently scTDC1 has two ways of memory treatment for data pipes. One is so called 'internal' memory allocation, when memory is allocated by scTDC1 and deallocated in the moment when next <a class="el" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2()</a>, <a class="el" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2()</a> or <a class="el" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2()</a> called. Second one - 'external' - when application supplies allocator callback function in data pipe parameters. In this case allocator callback function is called every time when data pipe processing algorithm needs memory for the data. Deallocation must be performed by the application.</p>
<p>Simple example for statistics pipe with external allocator: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Allocator
{
    <span class="comment">// This is allocator class which will store all statistics in the mem_chunks_.</span>
    <span class="comment">//Deallocation happens when the object is destroyed.</span>
    std::list &lt;std::unique_ptr &lt;unsigned char []&gt; &gt; mem_chunks_;
    <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size_;
  <span class="keyword">public</span>:
    Allocator (<span class="keywordtype">size_t</span> s) :chunk_size_(s) {}
    <span class="keyword">static</span> <span class="keywordtype">int</span> pre_alloc(<span class="keywordtype">void</span> *p, <span class="keywordtype">void</span> **u) {
      <span class="keywordflow">return</span> (static_cast &lt;Allocator *&gt; (p))-&gt;alloc(u);
    }

    <span class="keywordtype">int</span> alloc(<span class="keywordtype">void</span> **u) {
      std::unique_ptr &lt;unsigned char []&gt; chunk(<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> [chunk_size_]);
      memset(&amp;(chunk[0]), 0, chunk_size_); <span class="comment">//scTDC does not &#39;zeroing&#39; memory supplied!</span>
      *u = &amp;(chunk[0]);
      mem_chunks_.push_back(std::move(chunk));
      <span class="keywordflow">return</span> 0;
    }
};

<span class="keywordtype">int</span> statistics_pipe_ex()
{
  <span class="keywordtype">int</span> dd = <a class="code" href="sc_t_d_c_8h.html#a11d123aaa034fedaaa321e90a9f28176" title="Initializes the hardware and loads the initial settings reading it from ini file.">sc_tdc_init_inifile</a>(<span class="stringliteral">&quot;tdc_gpx3.ini&quot;</span>); <span class="comment">//init the hardware and get device descriptor</span>
  <span class="keywordflow">if</span> (dd &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(dd, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, dd, error_description);
    <span class="keywordflow">return</span> dd;
  }

  <a class="code" href="structsc__pipe__statistics__params__t.html" title="Parameters for STATISTICS pipe type.">sc_pipe_statistics_params_t</a> prms;
  memset(&amp;prms, 0, <span class="keyword">sizeof</span>(prms));
  Allocator mem(<span class="keyword">sizeof</span>(<a class="code" href="structstatistics__t.html" title="Measure statistics. First array index corresponds to device number in a component device...">statistics_t</a>));
  prms.allocator_owner = static_cast &lt;<span class="keywordtype">void</span> *&gt; (&amp;mem);
  prms.<a class="code" href="structsc__pipe__statistics__params__t.html#a7943a196e5416eaa0fb4e4f1705cd257">allocator_cb</a> = &amp;(mem.pre_alloc);

  <span class="keywordtype">int</span> pd = <a class="code" href="sc_t_d_c_8h.html#afbccffe9f8d461337272c77b1e8d99e9" title="Open data pipe.">sc_pipe_open2</a>(dd, <a class="code" href="sc_t_d_c__types_8h.html#a207ff2479453c33d928ad188b7f43ad2ae564c3a2b71506c3a10f8e6c9379c02d">STATISTICS</a>, (<span class="keywordtype">void</span> *)&amp;prms);
  <span class="keywordflow">if</span> (pd &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(pd, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, pd, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a5bd32ad2f4ac91e2304beb74f0f32939" title="Deinitializes the hardware.">sc_tdc_deinit</a>(dd);
    <span class="keywordflow">return</span> pd;
  }

  <span class="keywordtype">int</span> ret = <a class="code" href="sc_t_d_c_8h.html#a17cad5640ea7fda18cac602590b096ba" title="Start measure.">sc_tdc_start_measure2</a>(dd, 200); <span class="comment">// start 200 ms measure</span>
  <span class="keywordflow">if</span> (ret &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(ret, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, ret, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
    <a class="code" href="sc_t_d_c_8h.html#a5bd32ad2f4ac91e2304beb74f0f32939" title="Deinitializes the hardware.">sc_tdc_deinit</a>(dd);
    <span class="keywordflow">return</span> ret;
  }

  <a class="code" href="structstatistics__t.html" title="Measure statistics. First array index corresponds to device number in a component device...">statistics_t</a> *stat;

  <span class="comment">//During measure processing engine will call mem.pre_alloc function, which</span>
  <span class="comment">//allocates 1k chunk of memory, save it in the list and return to the processor.</span>
  <span class="comment">//The next function will unblock after measure is finished. Application</span>
  <span class="comment">//will get back statistics in the memory, which will be deallocated when mem</span>
  <span class="comment">//object is destroyed. If application call sc_start_measure2 &amp; sc_pipe_read2()</span>
  <span class="comment">//many times here mem object will accumulate memory chunks in the list.</span>
  <span class="comment">//Other nice application of this feature is making accumulation of the data</span>
  <span class="comment">// in the same memory space by giving always the same pointer. scTDC will not</span>
  <span class="comment">//&#39;zeroed&#39; memory supplied and data will accumulate in the same place.</span>
  <span class="comment">//This works for images and histograms as well.</span>
  <span class="keywordtype">int</span> ret = <a class="code" href="sc_t_d_c_8h.html#affe773d3d4aacb4db040219501abdf15" title="Read data from pipe.">sc_pipe_read2</a>(dd, pd, (<span class="keywordtype">void</span> *)&amp;stat, UINT32_MAX);
  <span class="keywordflow">if</span> (ret &lt; 0) {
    <span class="keywordtype">char</span> error_description[ERRSTRLEN];
    <a class="code" href="sc_t_d_c_8h.html#a725ca6972696496b146be6d1229c3656" title="Gives an error description in a text form.">sc_get_err_msg</a>(ret, error_description);
    printf(<span class="stringliteral">&quot;error! code: %d, message: %s\n&quot;</span>, ret, error_description);
    <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
    <a class="code" href="sc_t_d_c_8h.html#a5bd32ad2f4ac91e2304beb74f0f32939" title="Deinitializes the hardware.">sc_tdc_deinit</a>(dd);
    <span class="keywordflow">return</span> ret;
  }

  <span class="comment">//Here we can do something with statistics</span>

  <a class="code" href="sc_t_d_c_8h.html#a316ec3f4f28ba07db666d6e31d0758a6" title="Close data pipe.">sc_pipe_close2</a>(dd, pd);
  <a class="code" href="sc_t_d_c_8h.html#a292b239599362739468841af6ce90850" title="Deinitialize the hardware.">sc_tdc_deinit2</a>(dd);

  <span class="comment">//Here statistics is still accessible because mem object is still on the stack.</span>
  <span class="comment">//If &#39;internal&#39; memory allocation used this would be not true.</span>
  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="api1"></a>
Old API Notes</h2>
<p>Function which is marked as DEPRECATED belongs to the old API which has a number of problems which in principle cannot be resolved. It is still supported to make old applications work, but will be removed in the future. Please refrain from using it in new applications. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
